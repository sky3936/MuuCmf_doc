# 自动验证

自动验证是ThinkPHP模型层提供的一种数据验证方法，可以在使用create创建数据对象的时候自动进行数据验证。

### 验证规则

数据验证可以进行数据类型、业务规则、安全判断等方面的验证操作。

数据验证有两种方式：

1. 静态方式：在模型类里面通过$_validate属性定义验证规则。
2. 动态方式：使用模型类的validate方法动态创建自动验证规则。

无论是什么方式，验证规则的定义是统一的规则，定义格式为：

```php
array(
     array(验证字段1,验证规则,错误提示,[验证条件,附加规则,验证时间]),
     array(验证字段2,验证规则,错误提示,[验证条件,附加规则,验证时间]),
     ......
);
```

说明

>验证字段 （必须）

需要验证的表单字段名称，这个字段不一定是数据库字段，也可以是表单的一些辅助字段，例如确认密码和验证码等等。有个别验证规则和字段无关的情况下，验证字段是可以随意设置的，例如expire有效期规则是和表单字段无关的。如果定义了字段映射的话，这里的验证字段名称应该是实际的数据表字段而不是表单字段。

>验证规则 （必须）

要进行验证的规则，需要结合附加规则，如果在使用正则验证的附加规则情况下，系统还内置了一些常用正则验证的规则，可以直接作为验证规则使用，包括：require 字段必须、email 邮箱、url URL地址、currency 货币、number 数字。

>提示信息 （必须）

用于验证失败后的提示信息定义

>验证条件 （可选）

包含下面几种情况：

* self::EXISTS_VALIDATE 或者0 存在字段就验证（默认）
* self::MUST_VALIDATE 或者1 必须验证
* self::VALUE_VALIDATE或者2 值不为空的时候验证

>附加规则 （可选）

配合验证规则使用，包括下面一些规则：

|规则	|说明|
|----|----|
|regex|正则验证，定义的验证规则是一个正则表达式（默认）|
|function|函数验证，定义的验证规则是一个函数名|
|callback|方法验证，定义的验证规则是当前模型类的一个方法|
|confirm|验证表单中的两个字段是否相同，定义的验证规则是一个字段名|
|equal|验证是否等于某个值，该值由前面的验证规则定义|
|notequal|验证是否不等于某个值，该值由前面的验证规则定义（3.1.2版本新增）|
|in	|验证是否在某个范围内，定义的验证规则可以是一个数组或者逗号分割的字符串|
|notin	|验证是否不在某个范围内，定义的验证规则可以是一个数组或者逗号分割的字符串（3.1.2版本新增）|
|length|验证长度，定义的验证规则可以是一个数字（表示固定长度）或者数字范围（例如3,12 表示长度从3到12的范围）|
|between|验证范围，定义的验证规则表示范围，可以使用字符串或者数组，例如1,31或者array(1,31)|
|notbetween	|验证不在某个范围，定义的验证规则表示范围，可以使用字符串或者数组（3.1.2版本新增）|
|expire|验证是否在有效期，定义的验证规则表示时间范围，可以到时间，例如可以使用 2012-1-15,2013-1-15 表示当前提交有效期在2012-1-15到2013-1-15之间，也可以使用时间戳定义|
|ip_allow|验证IP是否允许，定义的验证规则表示允许的IP地址列表，用逗号分隔，例如201.12.2.5,201.12.2.6|
|ip_deny|验证IP是否禁止，定义的验证规则表示禁止的ip地址列表，用逗号分隔，例如201.12.2.5,201.12.2.6|
|unique|验证是否唯一，系统会根据字段目前的值查询数据库来判断是否存在相同的值，当表单数据中包含主键字段时unique不可用于判断主键字段本身|


* self::MODEL_INSERT或者1新增数据时候验证
* self::MODEL_UPDATE或者2编辑数据时候验证
* self::MODEL_BOTH或者3全部情况下验证（默认）

这里的验证时间需要注意，并非只有这三种情况，你可以根据业务需要增加其他的验证时间。

### 静态定义

在模型类里面预先定义好该模型的自动验证规则，我们称为静态定义。

举例说明，我们在模型类里面定义了$_validate属性如下：

```php
namespace Home\Model;
use Think\Model;
class UserModel extends Model{
   protected $_validate = array(
     array('verify','require','验证码必须！'), //默认情况下用正则进行验证
     array('name','','帐号名称已经存在！',0,'unique',1), // 在新增的时候验证name字段是否唯一
     array('value',array(1,2,3),'值的范围不正确！',2,'in'), // 当值不为空的时候判断是否在一个范围内
     array('repassword','password','确认密码不正确',0,'confirm'), // 验证确认密码是否和密码一致
     array('password','checkPwd','密码格式不正确',0,'function'), // 自定义函数验证密码格式
   );
}
```

定义好验证规则后，就可以在使用create方法创建数据对象的时候自动调用：

```php
$User = D("User"); // 实例化User对象
if (!$User->create()){
     // 如果创建失败 表示验证没有通过 输出错误提示信息
     exit($User->getError());
}else{
     // 验证通过 可以进行其他数据操作
}
```

在进行自动验证的时候，系统会对定义好的验证规则进行依次验证。如果某一条验证规则没有通过，则会报错，getError方法返回的错误信息（字符串）就是对应字段的验证规则里面的错误提示信息。

静态定义方式因为必须定义模型类，所以只能用D函数实例化模型
默认情况下，create方法是对表单提交的POST数据进行自动验证，如果你的数据来源不是表单post，仍然也可以进行自动验证，方法改进如下：

```php
$User = D("User"); // 实例化User对象
$data = getData(); // 通过getData方法获取数据源的（数组）数据
if (!$User->create($data)){
     // 对data数据进行验证
     exit($User->getError());
}else{
     // 验证通过 可以进行其他数据操作
}
```

一般情况下，create方法会自动判断当前是新增数据还是编辑数据（主要是通过表单的隐藏数据添加主键信息），你也可以明确指定当前创建的数据对象是新增还是编辑，例如：

```php
$User = D("User"); // 实例化User对象
if (!$User->create($_POST,1)){ // 指定新增数据
     // 如果创建失败 表示验证没有通过 输出错误提示信息
     exit($User->getError());
}else{
     // 验证通过 可以进行其他数据操作
}
```

create方法的第二个参数就用于指定自动验证规则中的验证时间，也就是说create方法的自动验证只会验证符合验证时间的验证规则。

我们在上面提到这里的验证时间并非只有这几种情况，你可以根据业务需要增加其他的验证时间，例如，你可以给登录操作专门指定验证时间为4。我们定义验证规则如下：

```php
namespace Home\Model;
use Think\Model;
class UserModel extends Model{
   protected $_validate = array(
     array('verify','require','验证码必须！'),  // 都有时间都验证
     array('name','checkName','帐号错误！',1,'function',4),  // 只在登录时候验证
     array('password','checkPwd','密码错误！',1,'function',4), // 只在登录时候验证
   );
}
```

那么，我们就可以在登录的时候使用

```php
$User = D("User"); // 实例化User对象
if (!$User->create($_POST,4)){ // 登录验证数据
     // 验证没有通过 输出错误提示信息
     exit($User->getError());
}else{
     // 验证通过 执行登录操作
}
```

### 动态验证

如果采用动态验证的方式，就比较灵活，可以根据不同的需要，在操作同一个模型的时候使用不同的验证规则，例如上面的静态验证方式可以改为：

```php
$rules = array(
     array('verify','require','验证码必须！'), //默认情况下用正则进行验证
     array('name','','帐号名称已经存在！',0,'unique',1), // 在新增的时候验证name字段是否唯一
     array('value',array(1,2,3),'值的范围不正确！',2,'in'), // 当值不为空的时候判断是否在一个范围内
     array('repassword','password','确认密码不正确',0,'confirm'), // 验证确认密码是否和密码一致
     array('password','checkPwd','密码格式不正确',0,'function'), // 自定义函数验证密码格式
);

$User = M("User"); // 实例化User对象
if (!$User->validate($rules)->create()){
     // 如果创建失败 表示验证没有通过 输出错误提示信息
     exit($User->getError());
}else{
     // 验证通过 可以进行其他数据操作
}
```

动态验证不依赖模型类的定义，所以通常用M函数实例化模型就可以

### 错误信息多语言支持

如果你希望支持多语言的错误信息提示，那么可以在验证规则里面如下定义：

```php
protected $_validate = array(
     array('verify','require','{%VERIFY_CODE_MUST}'), 
     array('name','','{%ACCOUNT_EXISTS}',0,'unique',1), 
);
```

其中VERIFY_CODE_MUST和ACCOUNT_EXISTS是我们在语言包里面定义的多语言变量。

如果是采用动态验证方式，则比较简单，直接在定义验证规则的时候使用L方法即可，例如：

```php
$rules = array(
     array('verify','require',L('VERIFY_CODE_MUST')), 
     array('name','',L('ACCOUNT_EXISTS'),0,'unique',1), 
);
```

### 批量验证

系统支持数据的批量验证功能，只需要在模型类里面设置patchValidate属性为true（ 默认为false），

```php
protected $patchValidate = true;
```

设置批处理验证后，getError() 方法返回的错误信息是一个数组，返回格式是：

```php
array("字段名1"=>"错误提示1","字段名2"=>"错误提示2"... )
```

前端可以根据需要需要自行处理，例如转换成json格式返回：

```php
$User = D("User"); // 实例化User对象
if (!$User->create()){
     // 如果创建失败 表示验证没有通过 输出错误提示信息
     $this->ajaxReturn($User->getError());
}else{
     // 验证通过 可以进行其他数据操作
}
```
