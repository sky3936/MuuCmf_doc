# 模板渲染

模板定义后就可以渲染模板输出，系统也支持直接渲染内容输出，模板赋值必须在模板渲染之前操作。

### 渲染模板

渲染模板输出最常用的是使用display方法，调用格式：

>display('[模板文件]'[,'字符编码'][,'输出类型'])模板文件的写法支持下面几种：

|用法|描述|
|----|-----|
|不带任何参数|自动定位当前操作的模板文件|
|[模块@][控制器:][操作]|常用写法，支持跨模块 模板主题可以和theme方法配合|
|完整的模板文件名|直接使用完整的模板文件名（包括模板后缀）|

下面是一个最典型的用法，不带任何参数：

```php
// 不带任何参数 自动定位当前操作的模板文件
$this->display();
```

表示系统会按照默认规则自动定位模板文件，其规则是：

如果当前没有启用模板主题则定位到：当前模块/默认视图目录/当前控制器/当前操作.html 如果有启用模板主题则定位到：当前模块/默认视图目录/当前主题/当前控制器/当前操作.html

如果有更改TMPL_FILE_DEPR设置（假设 'TMPL_FILE_DEPR'=>'_'）的话，则上面的自动定位规则变成： 当前模块/默认视图目录/当前控制器_当前操作.html 和 当前模块/默认视图目录/当前主题/当前控制器_当前操作.html。

所以通常display方法无需带任何参数即可输出对应的模板，这是模板输出的最简单的用法。

>通常默认的视图目录是View

如果没有按照模板定义规则来定义模板文件（或者需要调用其他控制器下面的某个模板），可以使用：

```php
// 指定模板输出
$this->display('edit'); 
```

表示调用当前控制器下面的edit模板

```php
$this->display('Member:read');
```

表示调用Member控制器下面的read模板。

如果我们使用了模板主题功能，那么也可以支持跨主题调用，

使用：

```php
$this->theme('blue')->display('User:edit'); 
```

表示调用blue主题下面的User控制器的edit模板。

如果你不希望每个主题都重复定义一些相同的模版文件的话，还可以启用差异主题定义方式，设置：

```php
'TMPL_LOAD_DEFAULTTHEME'=>true
```

设置后，如果blue主题下面不存在edit模板的话，就会自动定位到默认主题中的edit模板。

渲染输出不需要写模板文件的路径和后缀，确切地说，这里面的控制器和操作并不一定需要有实际对应的控制器和操作，只是一个目录名称和文件名称而已，例如，你的项目里面可能根本没有Public控制器，更没有Public控制器的menu操作，但是一样可以使用

```php
$this->display('Public:menu');
```

输出这个模板文件。理解了这个，模板输出就清晰了。

display方法支持在渲染输出的时候指定输出编码和类型，

例如，可以指定编码和类型：

```php
$this->display('read', 'utf-8', 'text/xml');
```

表示输出XML页面类型（配合你的应用需求可以输出很多类型）。

事情总有特例，如果的模板目录是自定义的，或者根本不需要按模块进行分目录存放，那么默认的display渲染规则就不能处理，这个时候，我们就需要使用另外一种方式来应对，直接传入模板文件名即可，

例如：

```php
$this->display('./Template/Public/menu.html');
```

这种方式需要指定模板路径和后缀，这里的Template/Public目录是位于当前项目入口文件位置下面。如果是其他的后缀文件，也支持直接输出，例如：$this->display('./Template/Public/menu.tpl');

只要./Template/Public/menu.tpl是一个实际存在的模板文件。

>要注意模板文件位置是相对于项目的入口文件，而不是模板目录。